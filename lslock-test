#!/usr/bin/python3

import fcntl, os
import subprocess
#import time
import string, random

#DEVNULL = open('/dev/null', 'w')

testdir = '/tmp/lslock-test/'

if not os.path.isdir(testdir):
    os.makedirs(testdir)

def gen_filename(size = 6, chars = string.ascii_uppercase + string.digits):
#got this function from http://stackoverflow.com/questions/2257441/random-string-generation-with-upper-case-letters-and-digits-in-python
    return ''.join(random.choice(chars) for _ in range(size))

NUMFILES = 5
testfilelist = list()
fdescriptors = list()
pid = str(os.getpid())
for _ in range(NUMFILES):
    testfile = testdir + gen_filename()
    tolock = random.randint(0, 2)
    subprocess.call(['touch', testfile])
    if tolock:
        testfilelist.append(pid + ' : ' + testfile)
        if tolock == 1:
            f = open(testfile, 'r')
            fcntl.flock(f.fileno(), fcntl.LOCK_SH) #Source: http://effbot.org/librarybook/fcntl.htm
        elif tolock == 2:
            f = open(testfile, 'r+')
            fcntl.flock(f.fileno(), fcntl.LOCK_EX)
        fdescriptors.append(f)

testscript = os.path.dirname(os.path.realpath(__file__)) + '/lslock' #name of script to test
testoutput = subprocess.check_output(['python3', testscript, testdir]).decode('utf-8').splitlines() #run the script and get the output
testoutputset = {i for i in testoutput} #Cost of checking whether an element of testfilelist is in testoutputset is O(1), hence total cost is O(n) where testfilelist has n elements.
diditfail = False
for line in testfilelist:
    if line not in testoutputset:
        print('Failed: %s is not in the test output' % line)
        diditfail = True

if not diditfail:
    print('Passed')

#from pprint import pprint
#pprint(testfileset)
#pprint(testoutput)


for f in fdescriptors:
    f.close()

'''test cases:
0. File as parameter rather than directory //do not implement here
1. Normal file: should not be accepted, hence is not accepted.
2. Hard link: same inode, no point
3. Soft link: target inode gets locked if you lock either link or target
4. Rubbish input: caught by directory check
5. Malicious input: caught by directory check (Python sanitizes)
'''
